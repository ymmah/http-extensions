<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Cache Digests for HTTP/2</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script>
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
<link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The CACHE_DIGEST Frame" href="#rfc.section.2"><link rel="Chapter" title="3 The SENDING_CACHE_DIGEST SETTINGS Parameter" href="#rfc.section.3"><link rel="Chapter" title="4 The ACCEPT_CACHE_DIGEST SETTINGS Parameter" href="#rfc.section.4"><link rel="Chapter" title="5 IANA Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" href="#rfc.section.7" title="7 References"><link rel="Appendix" title="A Encoding the CACHE_DIGEST frame as an HTTP Header" href="#rfc.section.A"><link rel="Appendix" title="B Acknowledgements" href="#rfc.section.B"><link rel="Appendix" title="C Changes" href="#rfc.section.C"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.995, 2018/02/11 11:19:36, XSLT vendor: libxslt http://xmlsoft.org/XSLT/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Oku, K."><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-httpbis-cache-digest-latest"><meta name="dcterms.issued" content="2018-03-01"><meta name="dcterms.abstract" content="This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache’s contents. Servers can then use this to inform their choices of what to push to clients."><meta name="description" content="This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache’s contents. Servers can then use this to inform their choices of what to push to clients."></head><body><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">HTTP Working Group</td><td class="right">K. Oku</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Fastly</td></tr><tr><td class="left">Intended status: Experimental</td><td class="right">M. Nottingham</td></tr><tr><td class="left">Expires: September 2, 2018</td><td class="right">March 1, 2018</td></tr></tbody></table><div id="rfc.title"><h1>Cache Digests for HTTP/2</h1><div class="filename">draft-ietf-httpbis-cache-digest-latest</div></div></header><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><div id="rfc.abstract.p.1"><p>This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache’s contents. Servers can then use this to inform their choices of what to push to clients.</p></div></section><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.2"><p>Working Group information can be found at <a href="http://httpwg.github.io/">http://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/cache-digest">https://github.com/httpwg/http-extensions/labels/cache-digest</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on September 2, 2018.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2018 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>   <a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>   <a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>   <a href="#the-cachedigest-frame">The CACHE_DIGEST Frame</a><ul><li><a href="#rfc.section.2.1">2.1.</a>   <a href="#client-behavior">Client Behavior</a><ul><li><a href="#rfc.section.2.1.1">2.1.1.</a>   <a href="#creating">Creating a digest</a></li><li><a href="#rfc.section.2.1.2">2.1.2.</a>   <a href="#adding">Adding a URL to the Digest-Value</a></li><li><a href="#rfc.section.2.1.3">2.1.3.</a>   <a href="#removing">Removing a URL to the Digest-Value</a></li><li><a href="#rfc.section.2.1.4">2.1.4.</a>   <a href="#fingerprint">Computing a fingerprint value</a></li><li><a href="#rfc.section.2.1.5">2.1.5.</a>   <a href="#key">Computing the key</a></li><li><a href="#rfc.section.2.1.6">2.1.6.</a>   <a href="#hash">Computing a Hash Value</a></li><li><a href="#rfc.section.2.1.7">2.1.7.</a>   <a href="#hash2">Computing an Alternative Hash Value</a></li></ul></li><li><a href="#rfc.section.2.2">2.2.</a>   <a href="#server-behavior">Server Behavior</a><ul><li><a href="#rfc.section.2.2.1">2.2.1.</a>   <a href="#querying">Querying the Digest for a Value</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>   <a href="#the-sendingcachedigest-settings-parameter">The SENDING_CACHE_DIGEST SETTINGS Parameter</a></li><li><a href="#rfc.section.4">4.</a>   <a href="#the-acceptcachedigest-settings-parameter">The ACCEPT_CACHE_DIGEST SETTINGS Parameter</a></li><li><a href="#rfc.section.5">5.</a>   <a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>   <a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>   <a href="#rfc.references">References</a><ul><li><a href="#rfc.section.7.1">7.1.</a>   <a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.7.2">7.2.</a>   <a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>   <a href="#encoding-the-cachedigest-frame-as-an-http-header">Encoding the CACHE_DIGEST frame as an HTTP Header</a></li><li><a href="#rfc.section.B">B.</a>   <a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.section.C">C.</a>   <a href="#changes">Changes</a><ul><li><a href="#rfc.section.C.1">C.1.</a>   <a href="#since-draft-ietf-httpbis-cache-digest-03">Since draft-ietf-httpbis-cache-digest-03</a></li><li><a href="#rfc.section.C.2">C.2.</a>   <a href="#since-draft-ietf-httpbis-cache-digest-02">Since draft-ietf-httpbis-cache-digest-02</a></li><li><a href="#rfc.section.C.3">C.3.</a>   <a href="#since-draft-ietf-httpbis-cache-digest-01">Since draft-ietf-httpbis-cache-digest-01</a></li><li><a href="#rfc.section.C.4">C.4.</a>   <a href="#since-draft-ietf-httpbis-cache-digest-00">Since draft-ietf-httpbis-cache-digest-00</a></li></ul></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></nav><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a> <a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> allows a server to “push” synthetic request/response pairs into a client’s cache optimistically. While there is strong interest in using this facility to improve perceived Web browsing performance, it is sometimes counterproductive because the client might already have cached the “pushed” response.</p></div><div id="rfc.section.1.p.2"><p>When this is the case, the bandwidth used to “push” the response is effectively wasted, and represents opportunity cost, because it could be used by other, more relevant responses. HTTP/2 allows a stream to be cancelled by a client using a RST_STREAM frame in this situation, but there is still at least one round trip of potentially wasted capacity even then.</p></div><div id="rfc.section.1.p.3"><p>This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache’s contents using a Cuckoo-filter <a href="#Cuckoo"><cite title="Cuckoo Filter: Practically Better Than Bloom">[Cuckoo]</cite></a> based digest. Servers can then use this to inform their choices of what to push to clients.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div></section></section><section id="the-cachedigest-frame"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#the-cachedigest-frame">The CACHE_DIGEST Frame</a></h2><div id="rfc.section.2.p.1"><p>The CACHE_DIGEST frame type is 0xd (decimal 13).</p></div><div id="rfc.figure.u.1"><pre>
+-------------------------------+-------------------------------+
|         Origin-Len (16)       | Origin? (\*)                ...
+-------------------------------+-------------------------------+
|                   Digest-Value? (\*)                        ...
+---------------------------------------------------------------+
</pre></div><div id="rfc.section.2.p.2" class="avoidbreakafter"><p>The CACHE_DIGEST frame payload has the following fields:</p></div><div id="rfc.section.2.p.3"><dl class="compact"><dt>Origin-Len:</dt><dd>An unsigned, 16-bit integer indicating the length, in octets, of the Origin field.</dd><dt>Origin:</dt><dd>A sequence of characters containing the ASCII serialization of an origin (<a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>, Section 6.2) that the Digest-Value applies to.</dd><dt>Digest-Value:</dt><dd>A sequence of octets containing the digest as computed in <a href="#creating" title="Creating a digest">Section 2.1.1</a> and <a href="#adding" title="Adding a URL to the Digest-Value">Section 2.1.2</a>.</dd></dl></div><div id="rfc.section.2.p.4" class="avoidbreakafter"><p>The CACHE_DIGEST frame defines the following flags:</p></div><div id="rfc.section.2.p.5"><ul><li><strong>RESET</strong> (0x1): When set, indicates that any and all cache digests for the applicable origin held by the recipient MUST be considered invalid.</li><li><strong>COMPLETE</strong> (0x2): When set, indicates that the currently valid set of cache digests held by the server constitutes a complete representation of the cache’s state regarding that origin, for the type of cached response indicated by the <span class="tt">STALE</span> flag.</li><li><strong>VALIDATORS</strong> (0x4): When set, indicates that the <span class="tt">validators</span> boolean in <a href="#key" title="Computing the key">Section 2.1.5</a> is true.</li><li><strong>STALE</strong> (0x8): When set, indicates that all cached responses represented in the digest-value are stale <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a> at the point in them that the digest was generated; otherwise, all are fresh.</li></ul></div><section id="client-behavior"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#client-behavior">Client Behavior</a></h3><div id="rfc.section.2.1.p.1"><p>A CACHE_DIGEST frame MUST be sent from a client to a server on stream 0, and conveys a digest of the contents of the client’s cache for the indicated origin.</p></div><div id="rfc.section.2.1.p.2"><p>In typical use, a client will send one or more CACHE_DIGESTs immediately after the first request on a connection for a given origin, on the same stream, because there is usually a short period of inactivity then, and servers can benefit most when they understand the state of the cache before they begin pushing associated assets (e.g., CSS, JavaScript and images). Clients MAY send CACHE_DIGEST at other times.</p></div><div id="rfc.section.2.1.p.3"><p>If the cache’s state is cleared, lost, or the client otherwise wishes the server to stop using previously sent CACHE_DIGESTs, it can send a CACHE_DIGEST with the RESET flag set.</p></div><div id="rfc.section.2.1.p.4"><p>When generating CACHE_DIGEST, a client MUST NOT include cached responses whose URLs do not share origins <a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a> with the indicated origin. Clients MUST NOT send CACHE_DIGEST frames on connections that are not authoritative (as defined in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, 10.1) for the indicated origin.</p></div><div id="rfc.section.2.1.p.5"><p>CACHE_DIGEST allows the client to indicate whether the set of URLs used to compute the digest represent fresh or stale stored responses, using the STALE flag. Clients MAY decide whether to only send CACHE_DIGEST frames representing their fresh stored responses, their stale stored responses, or both.</p></div><div id="rfc.section.2.1.p.6"><p>Clients can choose to only send a subset of the suitable stored responses of each type (fresh or stale). However, when the CACHE_DIGEST frames sent represent the complete set of stored responses of a given type, the last such frame SHOULD have a COMPLETE flag set, to indicate to the server that it has all relevant state of that type. Note that for the purposes of COMPLETE, responses cached since the beginning of the connection or the last RESET flag on a CACHE_DIGEST frame need not be included.</p></div><div id="rfc.section.2.1.p.7"><p>CACHE_DIGEST can be computed to include cached responses’ ETags, as indicated by the VALIDATORS flag. This information can be used by servers to decide what kinds of responses to push to clients; for example, a stale response that hasn’t changed could be refreshed with a 304 (Not Modified) response; one that has changed can be replaced with a 200 (OK) response, whether the cached response was fresh or stale.</p></div><div id="rfc.section.2.1.p.8"><p>CACHE_DIGEST has no defined meaning when sent from servers, and SHOULD be ignored by clients.</p></div><section id="creating"><h4 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#creating">Creating a digest</a></h4><div id="rfc.section.2.1.1.p.1" class="avoidbreakafter"><p>Given the following inputs:</p></div><div id="rfc.section.2.1.1.p.2"><ul><li><span class="tt">P</span>, an integer smaller than 256, that indicates the probability of a false positive that is acceptable, expressed as <span class="tt">1/2\*\*P</span>.</li><li><span class="tt">N</span>, an integer that represents the number of entries - a prime number smaller than 2**32</li></ul></div><div id="rfc.section.2.1.1.p.3"><ol><li>Let <span class="tt">f</span> be the number of bits per fingerprint, calculated as <span class="tt">P + 3</span></li><li>Let <span class="tt">b</span> be the bucket size, defined as 4.</li><li>Let <span class="tt">allocated</span> be the closest power of 2 that is larger than <span class="tt">N</span>.</li><li>Let <span class="tt">bytes</span> be <span class="tt">f</span>*<span class="tt">allocated</span>*<span class="tt">b</span>/8 rounded up to the nearest integer</li><li>Add 5 to <span class="tt">bytes</span></li><li>Allocate memory of <span class="tt">bytes</span> and set it to zero. Assign it to <span class="tt">digest-value</span>.</li><li>Set the first byte to <span class="tt">P</span></li><li>Set the second till fifth bytes to <span class="tt">N</span> in big endian form</li><li>Return the <span class="tt">digest-value</span>.</li></ol></div><div id="rfc.section.2.1.1.p.4"><p>Note: <span class="tt">allocated</span> is necessary due to the nature of the way Cuckoo filters are creating the secondary hash, by XORing the initial hash and the fingerprint’s hash. The XOR operation means that secondary hash can pick an entry beyond the initial number of entries, up to the next power of 2. In order to avoid issues there, we allocate the table appropriately. For increased space efficiency, it is recommended that implementations pick a number of entries that’s close to the next power of 2.</p></div></section><section id="adding"><h4 id="rfc.section.2.1.2"><a href="#rfc.section.2.1.2">2.1.2.</a> <a href="#adding">Adding a URL to the Digest-Value</a></h4><div id="rfc.section.2.1.2.p.1" class="avoidbreakafter"><p>Given the following inputs:</p></div><div id="rfc.section.2.1.2.p.2"><ul><li><span class="tt">URL</span> a string corresponding to the Effective Request URI (<a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 5.5) of a cached response <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a></li><li><span class="tt">ETag</span> a string corresponding to the entity-tag <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a> of a cached response <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a> (if the ETag is available; otherwise, null);</li><li><span class="tt">maxcount</span> - max number of cuckoo hops</li><li><span class="tt">digest-value</span></li></ul></div><div id="rfc.section.2.1.2.p.3"><ol><li>Let <span class="tt">f</span> be the value of the first byte of <span class="tt">digest-value</span>.</li><li>Let <span class="tt">b</span> be the bucket size, defined as 4.</li><li>Let <span class="tt">N</span> be the value of the second to fifth bytes of <span class="tt">digest-value</span> in big endian form.</li><li>Let <span class="tt">key</span> be the return value of <a href="#key" title="Computing the key">Section 2.1.5</a> with <span class="tt">URL</span> and <span class="tt">ETag</span> as inputs.</li><li>Let <span class="tt">h1</span> be the return value of <a href="#hash" title="Computing a Hash Value">Section 2.1.6</a> with <span class="tt">key</span> and <span class="tt">N</span> as inputs.</li><li>Let <span class="tt">dest_fingerprint</span> be the return value of <a href="#fingerprint" title="Computing a fingerprint value">Section 2.1.4</a> with <span class="tt">key</span> and <span class="tt">f</span> as inputs.</li><li>Let <span class="tt">h2</span> be the return value of <a href="#hash2" title="Computing an Alternative Hash Value">Section 2.1.7</a> with <span class="tt">h1</span>, <span class="tt">dest_fingerprint</span> and <span class="tt">N</span> as inputs.</li><li>Let <span class="tt">h</span> be either <span class="tt">h1</span> or <span class="tt">h2</span>, picked in random.</li><li>While <span class="tt">maxcount</span> is larger than zero: <ol><li>Let <span class="tt">position_start</span> be 40 + <span class="tt">h</span> * <span class="tt">f</span> * <span class="tt">b</span>.</li><li>Let <span class="tt">position_end</span> be <span class="tt">position_start</span> + <span class="tt">f</span> * <span class="tt">b</span>.</li><li>While <span class="tt">position_start</span> &lt; <span class="tt">position_end</span>: <ol><li>Let <span class="tt">bits</span> be <span class="tt">f</span> bits from <span class="tt">digest_value</span> starting at <span class="tt">position_start</span>.</li><li>If <span class="tt">bits</span> is all zeros, set <span class="tt">bits</span> to <span class="tt">dest_fingerprint</span> and terminate these steps.</li><li>Add <span class="tt">f</span> to <span class="tt">position_start</span>.</li></ol></li><li>Let <span class="tt">e</span> be a random number from 0 to <span class="tt">b</span>.</li><li>Subtract <span class="tt">f</span> * (<span class="tt">b</span> - <span class="tt">e</span>) from <span class="tt">position_start</span>.</li><li>Let <span class="tt">bits</span> be <span class="tt">f</span> bits from <span class="tt">digest_value</span> starting at <span class="tt">position_start</span>.</li><li>Let <span class="tt">fingerprint</span> be the value of bits, read as big endian.</li><li>Set <span class="tt">bits</span> to <span class="tt">dest_fingerprint</span>.</li><li>Set <span class="tt">dest_fingerprint</span> to <span class="tt">fingerprint</span>.</li><li>Let <span class="tt">h</span> be <a href="#hash2" title="Computing an Alternative Hash Value">Section 2.1.7</a> with <span class="tt">h</span>, <span class="tt">dest_fingerprint</span> and <span class="tt">N</span> as inputs.</li><li>Subtract 1 from <span class="tt">maxcount</span>.</li></ol></li><li>Subtract <span class="tt">f</span> from <span class="tt">position_start</span>.</li><li>Let <span class="tt">fingerprint</span> be the <span class="tt">f</span> bits starting at <span class="tt">position_start</span>.</li><li>Let <span class="tt">h1</span> be <span class="tt">h</span></li><li>Subtract 1 from <span class="tt">maxcount</span>.</li><li>If <span class="tt">maxcount</span> is zero, return an error.</li><li>Go to step 7.</li></ol></div></section><section id="removing"><h4 id="rfc.section.2.1.3"><a href="#rfc.section.2.1.3">2.1.3.</a> <a href="#removing">Removing a URL to the Digest-Value</a></h4><div id="rfc.section.2.1.3.p.1" class="avoidbreakafter"><p>Given the following inputs:</p></div><div id="rfc.section.2.1.3.p.2"><ul><li><span class="tt">URL</span> a string corresponding to the Effective Request URI (<a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 5.5) of a cached response <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a></li><li><span class="tt">ETag</span> a string corresponding to the entity-tag <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a> of a cached response <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a> (if the ETag is available; otherwise, null);</li><li><span class="tt">digest-value</span></li></ul></div><div id="rfc.section.2.1.3.p.3"><ol><li>Let <span class="tt">f</span> be the value of the first byte of <span class="tt">digest-value</span>.</li><li>Let <span class="tt">b</span> be the bucket size, defined as 4.</li><li>Let <span class="tt">N</span> be the value of the second to fifth bytes of <span class="tt">digest-value</span> in big endian form.</li><li>Let <span class="tt">key</span> be the return value of <a href="#key" title="Computing the key">Section 2.1.5</a> with <span class="tt">URL</span> and <span class="tt">ETag</span> as inputs.</li><li>Let <span class="tt">h1</span> be the return value of <a href="#hash" title="Computing a Hash Value">Section 2.1.6</a> with <span class="tt">key</span> and <span class="tt">N</span> as inputs.</li><li>Let <span class="tt">fingerprint</span> be the return value of <a href="#fingerprint" title="Computing a fingerprint value">Section 2.1.4</a> with <span class="tt">key</span> and <span class="tt">f</span> as inputs.</li><li>Let <span class="tt">h2</span> be the return value of <a href="#hash2" title="Computing an Alternative Hash Value">Section 2.1.7</a> with <span class="tt">h1</span>, <span class="tt">fingerprint</span> and <span class="tt">N</span> as inputs.</li><li>Let <span class="tt">hashes</span> be an array containing <span class="tt">h1</span> and <span class="tt">h2</span>.</li><li>For each <span class="tt">h</span> in <span class="tt">hashes</span>: <ol><li>Let <span class="tt">position_start</span> be 40 + <span class="tt">h</span> * <span class="tt">f</span> * <span class="tt">b</span>.</li><li>Let <span class="tt">position_end</span> be <span class="tt">position_start</span> + <span class="tt">f</span> * <span class="tt">b</span>.</li><li>While <span class="tt">position_start</span> &lt; <span class="tt">position_end</span>: <ol><li>Let <span class="tt">bits</span> be <span class="tt">f</span> bits from <span class="tt">digest_value</span> starting at <span class="tt">position_start</span>.</li><li>If <span class="tt">bits</span> is <span class="tt">fingerprint</span>, set <span class="tt">bits</span> to all zeros and terminate these steps.</li><li>Add <span class="tt">f</span> to <span class="tt">position_start</span>.</li></ol></li></ol></li></ol></div></section><section id="fingerprint"><h4 id="rfc.section.2.1.4"><a href="#rfc.section.2.1.4">2.1.4.</a> <a href="#fingerprint">Computing a fingerprint value</a></h4><div id="rfc.section.2.1.4.p.1" class="avoidbreakafter"><p>Given the following inputs:</p></div><div id="rfc.section.2.1.4.p.2"><ul><li><span class="tt">key</span>, an array of characters</li><li><span class="tt">f</span>, an integer indicating the number of output bits</li></ul></div><div id="rfc.section.2.1.4.p.3"><ol><li>Let <span class="tt">hash-value</span> be the SHA-256 message digest <a href="#RFC6234"><cite title="US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)">[RFC6234]</cite></a> of <span class="tt">key</span>, expressed as an integer.</li><li>Let <span class="tt">h</span> be the number of bits in <span class="tt">hash-value</span></li><li>Let <span class="tt">fingerprint-value</span> be 0</li><li>While <span class="tt">fingerprint-value</span> is 0 and <span class="tt">h</span> &gt; <span class="tt">f</span>: <ol><li>Let <span class="tt">fingerprint-value</span> be the <span class="tt">f</span> least significant bits of <span class="tt">hash-value</span>.</li><li>Let <span class="tt">hash-value</span> be the <span class="tt">h</span>-<span class="tt">f</span> most significant bits of <span class="tt">hash-value</span>.</li><li>Subtract <span class="tt">f</span> from <span class="tt">h</span>.</li></ol></li><li>If <span class="tt">fingerprint-value</span> is 0, let <span class="tt">fingerprint-value</span> be 1.</li><li>Return <span class="tt">fingerprint-value</span>.</li></ol></div><div id="rfc.section.2.1.4.p.4"><p>Note: Step 5 is to handle the extremely unlikely case where a SHA-256 digest of <span class="tt">key</span> is all zeros. The implications of it means that there’s an infitisimaly larger probability of getting a <span class="tt">fingerprint-value</span> of 1 compared to all other values. This is not a problem for any practical purpose.</p></div></section><section id="key"><h4 id="rfc.section.2.1.5"><a href="#rfc.section.2.1.5">2.1.5.</a> <a href="#key">Computing the key</a></h4><div id="rfc.section.2.1.5.p.1" class="avoidbreakafter"><p>Given the following inputs:</p></div><div id="rfc.section.2.1.5.p.2"><ul><li><span class="tt">URL</span>, an array of characters</li><li><span class="tt">ETag</span>, an array of characters</li><li><span class="tt">validators</span>, a boolean indicating whether validators (<a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>) are to be included in the digest</li></ul></div><div id="rfc.section.2.1.5.p.3"><ol><li>Let <span class="tt">key</span> be <span class="tt">URL</span> converted to an ASCII string by percent-encoding as appropriate <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>.</li><li>If <span class="tt">validators</span> is true and <span class="tt">ETag</span> is not null: <ol><li>Append <span class="tt">ETag</span> to <span class="tt">key</span> as an ASCII string, including both the <span class="tt">weak</span> indicator (if present) and double quotes, as per <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>, Section 2.3.</li></ol></li><li>Return <span class="tt">key</span></li></ol></div><div id="rfc.section.2.1.5.p.4"><p>TODO: Add an example of the ETag and the key calcuations.</p></div></section><section id="hash"><h4 id="rfc.section.2.1.6"><a href="#rfc.section.2.1.6">2.1.6.</a> <a href="#hash">Computing a Hash Value</a></h4><div id="rfc.section.2.1.6.p.1" class="avoidbreakafter"><p>Given the following inputs:</p></div><div id="rfc.section.2.1.6.p.2"><ul><li><span class="tt">key</span>, an array of characters.</li><li><span class="tt">N</span>, an integer</li></ul></div><div id="rfc.section.2.1.6.p.3" class="avoidbreakafter"><p><span class="tt">hash-value</span> can be computed using the following algorithm:</p></div><div id="rfc.section.2.1.6.p.4"><ol><li>Let <span class="tt">hash-value</span> be the SHA-256 message digest <a href="#RFC6234"><cite title="US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)">[RFC6234]</cite></a> of <span class="tt">key</span>, truncated to 32 bits, expressed as an integer.</li><li>Return <span class="tt">hash-value</span> modulo N.</li></ol></div></section><section id="hash2"><h4 id="rfc.section.2.1.7"><a href="#rfc.section.2.1.7">2.1.7.</a> <a href="#hash2">Computing an Alternative Hash Value</a></h4><div id="rfc.section.2.1.7.p.1" class="avoidbreakafter"><p>Given the following inputs:</p></div><div id="rfc.section.2.1.7.p.2"><ul><li><span class="tt">hash1</span>, an integer indicating the previous hash.</li><li><span class="tt">fingerprint</span>, an integer indicating the fingerprint value.</li><li><span class="tt">N</span>, an integer indicating the number of entries in the digest.</li></ul></div><div id="rfc.section.2.1.7.p.3"><ol><li>Let <span class="tt">fingerprint-string</span> be the value of <span class="tt">fingerprint</span> in base 10, expressed as a string.</li><li>Let <span class="tt">hash2</span> be the return value of <a href="#hash" title="Computing a Hash Value">Section 2.1.6</a> with <span class="tt">fingerprint-string</span> and <span class="tt">N</span> as inputs, XORed with <span class="tt">hash1</span>.</li><li>Return <span class="tt">hash2</span>.</li></ol></div></section></section><section id="server-behavior"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#server-behavior">Server Behavior</a></h3><div id="rfc.section.2.2.p.1"><p>In typical use, a server will query (as per <a href="#querying" title="Querying the Digest for a Value">Section 2.2.1</a>) the CACHE_DIGESTs received on a given connection to inform what it pushes to that client;</p></div><div id="rfc.section.2.2.p.2"><ul><li>If a given URL and ETag combination has a match in a current CACHE_DIGEST, a complete response need not be pushed; The server MAY push a 304 response for that resource, indicating the client that it hasn’t changed.</li><li>If a given URL and ETag has no match in any current CACHE_DIGEST, the client does not have a cached copy, and a complete response can be pushed.</li></ul></div><div id="rfc.section.2.2.p.3"><p>Servers MAY use all CACHE_DIGESTs received for a given origin as current, as long as they do not have the RESET flag set; a CACHE_DIGEST frame with the RESET flag set MUST clear any previously stored CACHE_DIGESTs for its origin. Servers MUST treat an empty Digest-Value with a RESET flag set as effectively clearing all stored digests for that origin.</p></div><div id="rfc.section.2.2.p.4"><p>Clients are not likely to send updates to CACHE_DIGEST over the lifetime of a connection; it is expected that servers will separately track what cacheable responses have been sent previously on the same connection, using that knowledge in conjunction with that provided by CACHE_DIGEST.</p></div><div id="rfc.section.2.2.p.5"><p>Servers MUST ignore CACHE_DIGEST frames sent on a stream other than 0.</p></div><section id="querying"><h4 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#querying">Querying the Digest for a Value</a></h4><div id="rfc.section.2.2.1.p.1" class="avoidbreakafter"><p>Given the following inputs:</p></div><div id="rfc.section.2.2.1.p.2"><ul><li><span class="tt">URL</span> a string corresponding to the Effective Request URI (<a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 5.5) of a cached response <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>.</li><li><span class="tt">ETag</span> a string corresponding to the entity-tag <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a> of a cached response <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a> (if the ETag is available; otherwise, null).</li><li><span class="tt">validators</span>, a boolean</li><li><span class="tt">digest-value</span>, an array of bits.</li></ul></div><div id="rfc.section.2.2.1.p.3"><ol><li>Let <span class="tt">f</span> be the value of the first byte of <span class="tt">digest-value</span>.</li><li>Let <span class="tt">b</span> be the bucket size, defined as 4.</li><li>Let <span class="tt">N</span> be the value of the second to fifth bytes of <span class="tt">digest-value</span> in big endian form.</li><li>Let <span class="tt">key</span> be the return value of <a href="#key" title="Computing the key">Section 2.1.5</a> with <span class="tt">URL</span> and <span class="tt">ETag</span> as inputs.</li><li>Let <span class="tt">h1</span> be the return value of <a href="#hash" title="Computing a Hash Value">Section 2.1.6</a> with <span class="tt">key</span> and <span class="tt">N</span> as inputs.</li><li>Let <span class="tt">fingerprint</span> be the return value of <a href="#fingerprint" title="Computing a fingerprint value">Section 2.1.4</a> with <span class="tt">key</span> and <span class="tt">f</span> as inputs.</li><li>Let <span class="tt">h2</span> be the return value of <a href="#hash2" title="Computing an Alternative Hash Value">Section 2.1.7</a> with <span class="tt">h1</span>, <span class="tt">fingerprint</span> and <span class="tt">N</span> as inputs.</li><li>Let <span class="tt">hashes</span> be an array containing <span class="tt">h1</span> and <span class="tt">h2</span>.</li><li>For each <span class="tt">h</span> in <span class="tt">hashes</span>: <ol><li>Let <span class="tt">position_start</span> be 40 + <span class="tt">h</span> * <span class="tt">f</span> * <span class="tt">b</span>.</li><li>Let <span class="tt">position_end</span> be <span class="tt">position_start</span> + <span class="tt">f</span> * <span class="tt">b</span>.</li><li>While <span class="tt">position_start</span> &lt; <span class="tt">position_end</span>: <ol><li>Let <span class="tt">bits</span> be <span class="tt">f</span> bits from <span class="tt">digest_value</span> starting at <span class="tt">position_start</span>.</li><li>If <span class="tt">bits</span> is <span class="tt">fingerprint</span>, return true</li><li>Add <span class="tt">f</span> to <span class="tt">position_start</span>.</li></ol></li></ol></li><li>Return false.</li></ol></div></section></section></section><section id="the-sendingcachedigest-settings-parameter"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#the-sendingcachedigest-settings-parameter">The SENDING_CACHE_DIGEST SETTINGS Parameter</a></h2><div id="rfc.section.3.p.1"><p>A Client SHOULD notify its support for CACHE_DIGEST frames by sending the SENDING_CACHE_DIGEST (0xXXX) SETTINGS parameter.</p></div><div id="rfc.section.3.p.2" class="avoidbreakafter"><p>The value of the parameter is a bit-field of which the following bits are defined:</p></div><div id="rfc.section.3.p.3"><p>DIGEST_PENDING (0x1): When set it indicates that the client has a digest to send, and the server may choose to wait for a digest in order to make server push decisions.</p></div><div id="rfc.section.3.p.4"><p>Rest of the bits MUST be ignored and MUST be left unset when sending.</p></div><div id="rfc.section.3.p.5"><p>The initial value of the parameter is zero (0x0) meaning that the client has no digest to send the server.</p></div></section><section id="the-acceptcachedigest-settings-parameter"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#the-acceptcachedigest-settings-parameter">The ACCEPT_CACHE_DIGEST SETTINGS Parameter</a></h2><div id="rfc.section.4.p.1"><p>A server can notify its support for CACHE_DIGEST frame by sending the ACCEPT_CACHE_DIGEST (0x7) SETTINGS parameter. If the server is tempted to making optimizations based on CACHE_DIGEST frames, it SHOULD send the SETTINGS parameter immediately after the connection is established.</p></div><div id="rfc.section.4.p.2" class="avoidbreakafter"><p>The value of the parameter is a bit-field of which the following bits are defined:</p></div><div id="rfc.section.4.p.3"><p>ACCEPT (0x1): When set, it indicates that the server is willing to make use of a digest of cached responses.</p></div><div id="rfc.section.4.p.4"><p>Rest of the bits MUST be ignored and MUST be left unset when sending.</p></div><div id="rfc.section.4.p.5"><p>The initial value of the parameter is zero (0x0) meaning that the server is not interested in seeing a CACHE_DIGEST frame.</p></div><div id="rfc.section.4.p.6"><p>Some underlying transports allow the server’s first flight of application data to reach the client at around the same time when the client sends it’s first flight data. When such transport (e.g., TLS 1.3 <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a> in full-handshake mode) is used, a client can postpone sending the CACHE_DIGEST frame until it receives a ACCEPT_CACHE_DIGEST settings value.</p></div><div id="rfc.section.4.p.7"><p>When the underlying transport does not have such property (e.g., TLS 1.3 in 0-RTT mode), a client can reuse the settings value found in previous connections to that origin <a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a> to make assumptions.</p></div></section><section id="iana-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.5.p.1" class="avoidbreakafter"><p>This document registers the following entry in the Permanent Message Headers Registry, as per <a href="#RFC3864"><cite title="Registration Procedures for Message Header Fields">[RFC3864]</cite></a>:</p></div><div id="rfc.section.5.p.2"><ul><li>Header field name: Cache-Digest</li><li>Applicable protocol: http</li><li>Status: experimental</li><li>Author/Change controller: IESG</li><li>Specification document(s): [this document]</li></ul></div><div id="rfc.section.5.p.3" class="avoidbreakafter"><p>This document registers the following entry in the HTTP/2 Frame Type Registry, as per <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>:</p></div><div id="rfc.section.5.p.4"><ul><li>Frame Type: CACHE_DIGEST</li><li>Code: 0xd</li><li>Specification: [this document]</li></ul></div><div id="rfc.section.5.p.5" class="avoidbreakafter"><p>This document registers the following entry in the HTTP/2 Settings Registry, as per <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>:</p></div><div id="rfc.section.5.p.6"><ul><li>Code: 0x7</li><li>Name: ACCEPT_CACHE_DIGEST</li><li>Initial Value: 0x0</li><li>Reference: [this document]</li></ul></div></section><section id="security-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.6.p.1"><p>The contents of a User Agent’s cache can be used to re-identify or “fingerprint” the user over time, even when other identifiers (e.g., Cookies <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a>) are cleared.</p></div><div id="rfc.section.6.p.2"><p>CACHE_DIGEST allows such cache-based fingerprinting to become passive, since it allows the server to discover the state of the client’s cache without any visible change in server behaviour.</p></div><div id="rfc.section.6.p.3"><p>As a result, clients MUST mitigate for this threat when the user attempts to remove identifiers (e.g., “clearing cookies”). This could be achieved in a number of ways; for example: by clearing the cache, by changing one or both of N and P, or by adding new, synthetic entries to the digest to change its contents.</p></div><div id="rfc.section.6.p.4"><p>TODO: discuss how effective the suggested mitigations actually would be.</p></div><div id="rfc.section.6.p.5"><p>Additionally, User Agents SHOULD NOT send CACHE_DIGEST when in “privacy mode.”</p></div></section><section id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> References</h2><section><div id="rfc.references.1"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> Normative References</h3><dl class="reference"><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP 14, RFC 2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC3986">[RFC3986]</dt><dd>Berners-Lee, T., Fielding, R., and L. Masinter, “<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>”, STD 66, RFC 3986, <a href="http://dx.doi.org/10.17487/RFC3986">DOI 10.17487/RFC3986</a>, January 2005, &lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;.</dd><dt id="RFC6234">[RFC6234]</dt><dd>Eastlake 3rd, D. and T. Hansen, “<a href="https://tools.ietf.org/html/rfc6234">US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</a>”, RFC 6234, <a href="http://dx.doi.org/10.17487/RFC6234">DOI 10.17487/RFC6234</a>, May 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6234">https://www.rfc-editor.org/info/rfc6234</a>&gt;.</dd><dt id="RFC6454">[RFC6454]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>”, RFC 6454, <a href="http://dx.doi.org/10.17487/RFC6454">DOI 10.17487/RFC6454</a>, December 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6454">https://www.rfc-editor.org/info/rfc6454</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC 7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI 10.17487/RFC7230</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7232">[RFC7232]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7232">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>”, RFC 7232, <a href="http://dx.doi.org/10.17487/RFC7232">DOI 10.17487/RFC7232</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7232">https://www.rfc-editor.org/info/rfc7232</a>&gt;.</dd><dt id="RFC7234">[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC 7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI 10.17487/RFC7234</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7234">https://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC 7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd></dl></div></section><section><div id="rfc.references.2"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> Informative References</h3><dl class="reference"><dt id="Cuckoo">[Cuckoo]</dt><dd>“<a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">Cuckoo Filter: Practically Better Than Bloom</a>”, n.d., &lt;<a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf</a>&gt;.</dd><dt id="Fetch">[Fetch]</dt><dd>“<a href="https://fetch.spec.whatwg.org/">Fetch Standard</a>”, n.d., &lt;<a href="https://fetch.spec.whatwg.org/">https://fetch.spec.whatwg.org/</a>&gt;.</dd><dt id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</dt><dd>Rescorla, E., “<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-22">The Transport Layer Security (TLS) Protocol Version 1.3</a>”, Internet-Draft draft-ietf-tls-tls13-22 (work in progress), November 2017.</dd><dt id="RFC3864">[RFC3864]</dt><dd>Klyne, G., Nottingham, M., and J. Mogul, “<a href="https://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>”, BCP 90, RFC 3864, <a href="http://dx.doi.org/10.17487/RFC3864">DOI 10.17487/RFC3864</a>, September 2004, &lt;<a href="https://www.rfc-editor.org/info/rfc3864">https://www.rfc-editor.org/info/rfc3864</a>&gt;.</dd><dt id="RFC4648">[RFC4648]</dt><dd>Josefsson, S., “<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>”, RFC 4648, <a href="http://dx.doi.org/10.17487/RFC4648">DOI 10.17487/RFC4648</a>, October 2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.</dd><dt id="RFC5234">[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD 68, RFC 5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI 10.17487/RFC5234</a>, January 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt id="RFC6265">[RFC6265]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>”, RFC 6265, <a href="http://dx.doi.org/10.17487/RFC6265">DOI 10.17487/RFC6265</a>, April 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;.</dd><dt id="Service-Workers">[Service-Workers]</dt><dd>Russell, A., Song, J., Archibald, J., and M. Kruisselbrink, “<a href="https://www.w3.org/TR/2016/WD-service-workers-1-20161011/">Service Workers 1</a>”, W3C Working Draft WD-service-workers-1-20161011, October 2016, &lt;<a href="https://www.w3.org/TR/2016/WD-service-workers-1-20161011/">https://www.w3.org/TR/2016/WD-service-workers-1-20161011/</a>&gt;.</dd></dl></div></section></section><section id="encoding-the-cachedigest-frame-as-an-http-header"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a> <a href="#encoding-the-cachedigest-frame-as-an-http-header">Encoding the CACHE_DIGEST frame as an HTTP Header</a></h2><div id="rfc.section.A.p.1"><p>On some web browsers that support Service Workers <a href="#Service-Workers"><cite title="Service Workers 1">[Service-Workers]</cite></a> but not Cache Digests (yet), it is possible to achieve the benefit of using Cache Digests by emulating the frame using HTTP Headers.</p></div><div id="rfc.section.A.p.2"><p>For the sake of interoperability with such clients, this appendix defines how a CACHE_DIGEST frame can be encoded as an HTTP header named <span class="tt">Cache-Digest</span>.</p></div><div id="rfc.section.A.p.3"><p>The definition uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a> with the list rule extension defined in <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 7.</p></div><div id="rfc.figure.u.2"><pre class="inline">
  Cache-Digest  = 1#digest-entity
  digest-entity = digest-value *(OWS ";" OWS digest-flag)
  digest-value  = &lt;Digest-Value encoded using base64url&gt;
  digest-flag   = token
</pre></div><div id="rfc.section.A.p.4"><p>A Cache-Digest request header is defined as a list construct of cache-digest-entities. Each cache-digest-entity corresponds to a CACHE_DIGEST frame.</p></div><div id="rfc.section.A.p.5"><p>Digest-Value is encoded using base64url <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 5. Flags that are set are encoded as digest-flags by their names that are compared case-insensitively.</p></div><div id="rfc.section.A.p.6"><p>Origin is omitted in the header form. The value is implied from the value of the <span class="tt">:authority</span> pseudo header. Client MUST only send Cache-Digest headers containing digests that belong to the origin specified by the HTTP request.</p></div><div id="rfc.section.A.p.7"><p>The example below contains one digest of fresh resource and has only the <span class="tt">COMPLETE</span> flag set.</p></div><div id="rfc.figure.u.3"><pre class="text">
  Cache-Digest: AfdA; complete
</pre></div><div id="rfc.section.A.p.8"><p>Clients MUST associate Cache-Digest headers to every HTTP request, since Fetch <a href="#Fetch"><cite title="Fetch Standard">[Fetch]</cite></a> - the HTTP API supported by Service Workers - does not define the order in which the issued requests will be sent to the server nor guarantees that all the requests will be transmitted using a single HTTP/2 connection.</p></div><div id="rfc.section.A.p.9"><p>Also, due to the fact that any header that is supplied to Fetch is required to be end-to-end, there is an ambiguity in what a Cache-Digest header respresents when a request is transmitted through a proxy. The header may represent the cache state of a client or that of a proxy, depending on how the proxy handles the header.</p></div></section><section id="acknowledgements"><h2 id="rfc.section.B"><a href="#rfc.section.B">B.</a> <a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.B.p.1"><p>Thanks to Yoav Weiss for his idea and text to use Cuckoo Filter.</p></div><div id="rfc.section.B.p.2"><p>Thanks to Stefan Eissing for his suggestions.</p></div></section><section id="changes"><h2 id="rfc.section.C"><a href="#rfc.section.C">C.</a> <a href="#changes">Changes</a></h2><section id="since-draft-ietf-httpbis-cache-digest-03"><h3 id="rfc.section.C.1"><a href="#rfc.section.C.1">C.1.</a> <a href="#since-draft-ietf-httpbis-cache-digest-03">Since draft-ietf-httpbis-cache-digest-03</a></h3><div id="rfc.section.C.1.p.1"><ul><li>None yet.</li></ul></div></section><section id="since-draft-ietf-httpbis-cache-digest-02"><h3 id="rfc.section.C.2"><a href="#rfc.section.C.2">C.2.</a> <a href="#since-draft-ietf-httpbis-cache-digest-02">Since draft-ietf-httpbis-cache-digest-02</a></h3><div id="rfc.section.C.2.p.1"><ul><li>Switch to Cuckoo Filter.</li></ul></div></section><section id="since-draft-ietf-httpbis-cache-digest-01"><h3 id="rfc.section.C.3"><a href="#rfc.section.C.3">C.3.</a> <a href="#since-draft-ietf-httpbis-cache-digest-01">Since draft-ietf-httpbis-cache-digest-01</a></h3><div id="rfc.section.C.3.p.1"><ul><li>Added definition of the Cache-Digest header.</li><li>Introduce ACCEPT_CACHE_DIGEST SETTINGS parameter.</li><li>Change intended status from Standard to Experimental.</li></ul></div></section><section id="since-draft-ietf-httpbis-cache-digest-00"><h3 id="rfc.section.C.4"><a href="#rfc.section.C.4">C.4.</a> <a href="#since-draft-ietf-httpbis-cache-digest-00">Since draft-ietf-httpbis-cache-digest-00</a></h3><div id="rfc.section.C.4.p.1"><ul><li>Make the scope of a digest frame explicit and shift to stream 0.</li></ul></div></section></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Kazuho Oku</b><br>Fastly<br>EMail: <a href="mailto:kazuhooku@gmail.com">kazuhooku@gmail.com</a></address><address><b>Mark Nottingham</b><br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address></section></body></html>
